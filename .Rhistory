if (length(res_list) == 0) {
stop(sprintf("All replications failed for n = %s", n))
}
do.call(rbind, res_list)
}
# main run across n = 100, 500, 1000
Ns <- c(100, 500, 1000)
all_res <- do.call(rbind, lapply(Ns, run_for_n))
# summaries per n
summaries <- do.call(rbind, lapply(split(all_res, all_res$n), function(df) {
data.frame(
n = unique(df$n),
metric = c("Train RMSE", "Test RMSE", "Time (sec)"),
ShrinkageTrees_mean = c(
mean(df$rmse_st_train, na.rm = TRUE),
mean(df$rmse_st_test,  na.rm = TRUE),
mean(df$time_st,       na.rm = TRUE)
),
ShrinkageTrees_sd = c(
sd(df$rmse_st_train, na.rm = TRUE),
sd(df$rmse_st_test,  na.rm = TRUE),
sd(df$time_st,       na.rm = TRUE)
),
BART_mean = c(
mean(df$rmse_bart_train, na.rm = TRUE),
mean(df$rmse_bart_test,  na.rm = TRUE),
mean(df$time_bart,       na.rm = TRUE)
),
BART_sd = c(
sd(df$rmse_bart_train, na.rm = TRUE),
sd(df$rmse_bart_test,  na.rm = TRUE),
sd(df$time_bart,       na.rm = TRUE)
),
row.names = NULL,
check.names = FALSE
)
}))
print(summaries, row.names = FALSE)
# optional quick plots for the largest n
big_n <- max(Ns)
df_big <- subset(all_res, n == big_n)
op <- par(mfrow = c(1, 2))
boxplot(list(ST = df_big$rmse_st_test, BART = df_big$rmse_bart_test),
main = sprintf("Test RMSE (n = %d)", big_n), ylab = "RMSE")
boxplot(list(ST = df_big$time_st, BART = df_big$time_bart),
main = sprintf("Time (sec) (n = %d)", big_n), ylab = "seconds")
par(op)
# params
M         <- 15
p         <- 10
sigma_y   <- 1
ntree     <- 100
ndpost    <- 2500
nskip     <- 2500
local_hp  <- 1 / (2 * 2 * sqrt(ntree))  # base scale; we rescale by data range
store_ps  <- FALSE
# parallel cores
mc_cores  <- 5
# helper: safely add nthread=1 if the function supports it
.add_nthread_arg <- function(fun, args, nthread = 1) {
fn <- get(fun, envir = parent.env(environment()))
form <- names(formals(fn))
if ("nthread" %in% form) args$nthread <- nthread
args
}
# one replication for a given n
run_one <- function(seed, n, p, sigma_y, ntree, ndpost, nskip, local_hp, store_ps) {
set.seed(seed)
# data
X  <- matrix(rnorm(n * p), n, p)
f  <- (5 * X[, 3] - 2 * X[, 2] + X[, 4]^3)
y  <- f + rnorm(n, sd = sigma_y)
X_test <- matrix(rnorm(n * p), n, p)
y_true <- (5 * X_test[, 3] - 2 * X_test[, 2] + X_test[, 4]^3)
# init default outputs to ensure a complete row
rmse_st_train <- rmse_st_test <- NA_real_
rmse_bart_train <- rmse_bart_test <- NA_real_
time_st <- time_bart <- NA_real_
# ShrinkageTrees
t0 <- proc.time()[3]
st_fit <- try(
ShrinkageTrees(
y = y,
X_train = X,
X_test  = X_test,
outcome_type = "continuous",
number_of_trees = ntree,
prior_type = "standard",
local_hp = local_hp * (max(y) - min(y)),
N_post = ndpost,
N_burn = nskip,
store_posterior_sample = store_ps,
verbose = FALSE
),
silent = TRUE
)
t1 <- proc.time()[3]
time_st <- t1 - t0
if (!inherits(st_fit, "try-error")) {
yhat_train_st <- st_fit$train_predictions
yhat_test_st  <- st_fit$test_predictions
rmse_st_train <- sqrt(mean((yhat_train_st - f)^2))
rmse_st_test  <- sqrt(mean((yhat_test_st  - y_true)^2))
}
# BART::wbart
t2 <- proc.time()[3]
w_args <- list(
x.train = X, y.train = y, x.test = X_test,
ndpost = ndpost, nskip = nskip, ntree = ntree,
printevery = 0, cont = TRUE
)
w_args <- .add_nthread_arg("wbart", w_args, nthread = 1)
b_fit <- try(do.call(wbart, w_args), silent = TRUE)
t3 <- proc.time()[3]
time_bart <- t3 - t2
if (!inherits(b_fit, "try-error")) {
yhat_train_b <- b_fit$yhat.train.mean
yhat_test_b  <- b_fit$yhat.test.mean
rmse_bart_train <- sqrt(mean((yhat_train_b - f)^2))
rmse_bart_test  <- sqrt(mean((yhat_test_b  - y_true)^2))
}
data.frame(
n = n,
rmse_st_train = rmse_st_train,
rmse_st_test  = rmse_st_test,
rmse_bart_train = rmse_bart_train,
rmse_bart_test  = rmse_bart_test,
time_st = time_st,
time_bart = time_bart,
check.names = FALSE
)
}
# run M reps for one n, with robust binding
run_for_n <- function(n) {
seeds <- sample(1:10^9, M)
res_list <- parallel::mclapply(
seeds,
run_one,
n = n, p = p, sigma_y = sigma_y,
ntree = ntree, ndpost = ndpost, nskip = nskip,
local_hp = local_hp, store_ps = store_ps,
mc.cores = mc_cores
)
res_list <- Filter(function(x) !is.null(x) && is.data.frame(x), res_list)
if (length(res_list) == 0) {
stop(sprintf("All replications failed for n = %s", n))
}
do.call(rbind, res_list)
}
# main run across n = 100, 500, 1000
Ns <- c(100, 500, 1000)
all_res <- do.call(rbind, lapply(Ns, run_for_n))
# summaries per n
summaries <- do.call(rbind, lapply(split(all_res, all_res$n), function(df) {
data.frame(
n = unique(df$n),
metric = c("Train RMSE", "Test RMSE", "Time (sec)"),
ShrinkageTrees_mean = c(
mean(df$rmse_st_train, na.rm = TRUE),
mean(df$rmse_st_test,  na.rm = TRUE),
mean(df$time_st,       na.rm = TRUE)
),
ShrinkageTrees_sd = c(
sd(df$rmse_st_train, na.rm = TRUE),
sd(df$rmse_st_test,  na.rm = TRUE),
sd(df$time_st,       na.rm = TRUE)
),
BART_mean = c(
mean(df$rmse_bart_train, na.rm = TRUE),
mean(df$rmse_bart_test,  na.rm = TRUE),
mean(df$time_bart,       na.rm = TRUE)
),
BART_sd = c(
sd(df$rmse_bart_train, na.rm = TRUE),
sd(df$rmse_bart_test,  na.rm = TRUE),
sd(df$time_bart,       na.rm = TRUE)
),
row.names = NULL,
check.names = FALSE
)
}))
print(summaries, row.names = FALSE)
# optional quick plots for the largest n
big_n <- max(Ns)
df_big <- subset(all_res, n == big_n)
op <- par(mfrow = c(1, 2))
boxplot(list(ST = df_big$rmse_st_test, BART = df_big$rmse_bart_test),
main = sprintf("Test RMSE (n = %d)", big_n), ylab = "RMSE")
boxplot(list(ST = df_big$time_st, BART = df_big$time_bart),
main = sprintf("Time (sec) (n = %d)", big_n), ylab = "seconds")
par(op)
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
install.packages("ShrinkageTrees")
setwd("/Users/tijnjacobs/Library/CloudStorage/OneDrive-VrijeUniversiteitAmsterdam/Documents/GitHub/ShrinkageTrees")
system("git branch --show-current")
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()
pkgload::dev_help('CausalShrinkageForest')
library(devtools)
library(BART)
library(parallel)
library(tictoc)
library(dbarts)
library(BayesTree)
setwd("/Users/tijnjacobs/Library/CloudStorage/OneDrive-VrijeUniversiteitAmsterdam/Documents/GitHub/ShrinkageTrees")
system("git branch --show-current")
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
# devtools::test()
library(devtools)
library(BART)
library(parallel)
library(tictoc)
library(dbarts)
library(BayesTree)
setwd("/Users/tijnjacobs/Library/CloudStorage/OneDrive-VrijeUniversiteitAmsterdam/Documents/GitHub/ShrinkageTrees")
system("git branch --show-current")
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
# ---- simulate data ----
n <- 100
setwd("/Users/tijnjacobs/Library/CloudStorage/OneDrive-VrijeUniversiteitAmsterdam/Documents/GitHub/ShrinkageTrees")
system("git branch --show-current")
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
setwd("/Users/tijnjacobs/Library/CloudStorage/OneDrive-VrijeUniversiteitAmsterdam/Documents/GitHub/ShrinkageTrees")
system("git branch --show-current")
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
# devtools::test()        # runs all tests in tests/testthat/
# devtools::build()       # builds a tar.gz in your working dir
# devtools::check()       # runs R CMD check on it
# TO DO:
#   - Built tests for the standard bart prior
## ---- test_fusion_shrinkage_forest_continuous.R -----------------------------
set.seed(42)
## Small, low-dimensional setup
n <- 100
p <- 10
N_burn <- 100
N_post <- 100
## Simulate train features
Xc <- matrix(rnorm(n * p), n, p)        # control/prognostic block
Xt <- matrix(rnorm(n * p), n, p)        # treatment block
## Source indicator: 0 = OS, 1 = RCT  (about 60% RCT)
s  <- rbinom(n, 1, 0.6L)
## Treatment assignment (slightly different rates per source)
a  <- ifelse(s == 1L, rbinom(n, 1, 0.5), rbinom(n, 1, 0.7))
## True underlying components
m_true   <- 1.0 * Xc[,1] - 0.75 * Xc[,2]^2 + 0.5 * sin(Xc[,3])
tau_true <- 0.8 * Xt[,1] + 0.3 * Xt[,2] * Xt[,3]
c_true   <- -0.7 * Xc[,4] + 0.6 * Xc[,5] # only used when s == 0 (OS)
## Borrowing strength (rho) used in data gen (doesn't have to match the fit)
rho_true <- 0.9
## Link for treatment effect sign (b = +0.5 for A=1, -0.5 for A=0)
b <- ifelse(a == 1L, 0.5, -0.5)
## Generate outcome (continuous)
## y = m(x) + b * [ tau(x) + (1 - s) * rho_true * c(x) ] + epsilon
eps <- rnorm(n, 0, 1.0)
y   <- m_true + b * (tau_true + (1 - s) * rho_true * c_true) + eps
## Split test set (tiny)
n_test <- 10
Xc_te  <- matrix(rnorm(n_test * p), n_test, p)
Xt_te  <- matrix(rnorm(n_test * p), n_test, p)
## Indicators for test (all RCT by default is fine; give explicit here)
a_te <- rep(1L, n_test)
s_te <- rep(1L, n_test)
## Forest sizes (kept small for a quick run)
nt_control <- 50
nt_treat   <- 50
nt_deconf  <- 50
## Local HPs per your formula
local_hp_control <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_control))
local_hp_treat   <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_treat))
local_hp_deconf  <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_deconf))
## Global HPs (only needed for non-fixed priors in your wrapper)
global_hp_control <- 1
global_hp_treat   <- 1
global_hp_deconf  <- 1
## Prior type:
prior_type_val <- "standard"
## Run the model (continuous outcome)
fit <- FusionShrinkageForest(
y                         = y,
status                    = NULL,
X_train_control           = Xc,
X_train_treat             = Xt,
treatment_indicator_train = a,
source_indicator_train    = s,
X_test_control            = Xc_te,
X_test_treat              = Xt_te,
# X_test_deconf omitted -> defaults to X_test_control
treatment_indicator_test  = a_te,
source_indicator_test     = s_te,
outcome_type              = "continuous",
timescale                 = "time",
number_of_trees_control   = nt_control,
number_of_trees_treat     = nt_treat,
number_of_trees_deconf    = nt_deconf,
prior_type_control        = prior_type_val,
prior_type_treat          = prior_type_val,
prior_type_deconf         = prior_type_val,
local_hp_control          = local_hp_control,
local_hp_treat            = local_hp_treat,
local_hp_deconf           = local_hp_deconf,
## leave sigma NULL (estimated), keep rho fixed to 1 for now
sigma                     = NULL,
rho                       = 1,
rho_known                 = TRUE,
## small MCMC for a smoke test; increase for real runs
N_post                    = N_post,
N_burn                    = N_burn,
store_posterior_sample    = TRUE,
verbose                   = TRUE
)
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
# devtools::test()        # runs all tests in tests/testthat/
# devtools::build()       # builds a tar.gz in your working dir
# devtools::check()       # runs R CMD check on it
# TO DO:
#   - Built tests for the standard bart prior
## ---- test_fusion_shrinkage_forest_continuous.R -----------------------------
set.seed(42)
## Small, low-dimensional setup
n <- 100
p <- 10
N_burn <- 100
N_post <- 100
## Simulate train features
Xc <- matrix(rnorm(n * p), n, p)        # control/prognostic block
Xt <- matrix(rnorm(n * p), n, p)        # treatment block
## Source indicator: 0 = OS, 1 = RCT  (about 60% RCT)
s  <- rbinom(n, 1, 0.6L)
## Treatment assignment (slightly different rates per source)
a  <- ifelse(s == 1L, rbinom(n, 1, 0.5), rbinom(n, 1, 0.7))
## True underlying components
m_true   <- 1.0 * Xc[,1] - 0.75 * Xc[,2]^2 + 0.5 * sin(Xc[,3])
tau_true <- 0.8 * Xt[,1] + 0.3 * Xt[,2] * Xt[,3]
c_true   <- -0.7 * Xc[,4] + 0.6 * Xc[,5] # only used when s == 0 (OS)
## Borrowing strength (rho) used in data gen (doesn't have to match the fit)
rho_true <- 0.9
## Link for treatment effect sign (b = +0.5 for A=1, -0.5 for A=0)
b <- ifelse(a == 1L, 0.5, -0.5)
## Generate outcome (continuous)
## y = m(x) + b * [ tau(x) + (1 - s) * rho_true * c(x) ] + epsilon
eps <- rnorm(n, 0, 1.0)
y   <- m_true + b * (tau_true + (1 - s) * rho_true * c_true) + eps
## Split test set (tiny)
n_test <- 10
Xc_te  <- matrix(rnorm(n_test * p), n_test, p)
Xt_te  <- matrix(rnorm(n_test * p), n_test, p)
## Indicators for test (all RCT by default is fine; give explicit here)
a_te <- rep(1L, n_test)
s_te <- rep(1L, n_test)
## Forest sizes (kept small for a quick run)
nt_control <- 50
nt_treat   <- 50
nt_deconf  <- 50
## Local HPs per your formula
local_hp_control <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_control))
local_hp_treat   <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_treat))
local_hp_deconf  <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_deconf))
## Global HPs (only needed for non-fixed priors in your wrapper)
global_hp_control <- 1
global_hp_treat   <- 1
global_hp_deconf  <- 1
## Prior type:
prior_type_val <- "standard"
## Run the model (continuous outcome)
fit <- FusionShrinkageForest(
y                         = y,
status                    = NULL,
X_train_control           = Xc,
X_train_treat             = Xt,
treatment_indicator_train = a,
source_indicator_train    = s,
X_test_control            = Xc_te,
X_test_treat              = Xt_te,
# X_test_deconf omitted -> defaults to X_test_control
treatment_indicator_test  = a_te,
source_indicator_test     = s_te,
outcome_type              = "continuous",
timescale                 = "time",
number_of_trees_control   = nt_control,
number_of_trees_treat     = nt_treat,
number_of_trees_deconf    = nt_deconf,
prior_type_control        = prior_type_val,
prior_type_treat          = prior_type_val,
prior_type_deconf         = prior_type_val,
local_hp_control          = local_hp_control,
local_hp_treat            = local_hp_treat,
local_hp_deconf           = local_hp_deconf,
## leave sigma NULL (estimated), keep rho fixed to 1 for now
sigma                     = NULL,
rho                       = 1,
rho_known                 = TRUE,
## small MCMC for a smoke test; increase for real runs
N_post                    = N_post,
N_burn                    = N_burn,
store_posterior_sample    = TRUE,
verbose                   = TRUE
)
Rcpp::compileAttributes()     # regenerates src/RcppExports.cpp and R/RcppExports.R
devtools::clean_dll()
devtools::load_all()
# 1️⃣ Clean and rebuild the package
devtools::document()      # regenerates NAMESPACE + man / from roxygen2
devtools::load_all()      # compiles C++ code and loads the package into memory
## ---- test_fusion_shrinkage_forest_continuous.R -----------------------------
set.seed(42)
## Small, low-dimensional setup
n <- 100
p <- 10
N_burn <- 100
N_post <- 100
## Simulate train features
Xc <- matrix(rnorm(n * p), n, p)        # control/prognostic block
Xt <- matrix(rnorm(n * p), n, p)        # treatment block
## Source indicator: 0 = OS, 1 = RCT  (about 60% RCT)
s  <- rbinom(n, 1, 0.6L)
## Treatment assignment (slightly different rates per source)
a  <- ifelse(s == 1L, rbinom(n, 1, 0.5), rbinom(n, 1, 0.7))
## True underlying components
m_true   <- 1.0 * Xc[,1] - 0.75 * Xc[,2]^2 + 0.5 * sin(Xc[,3])
tau_true <- 0.8 * Xt[,1] + 0.3 * Xt[,2] * Xt[,3]
c_true   <- -0.7 * Xc[,4] + 0.6 * Xc[,5] # only used when s == 0 (OS)
## Borrowing strength (rho) used in data gen (doesn't have to match the fit)
rho_true <- 0.9
## Link for treatment effect sign (b = +0.5 for A=1, -0.5 for A=0)
b <- ifelse(a == 1L, 0.5, -0.5)
## Generate outcome (continuous)
## y = m(x) + b * [ tau(x) + (1 - s) * rho_true * c(x) ] + epsilon
eps <- rnorm(n, 0, 1.0)
y   <- m_true + b * (tau_true + (1 - s) * rho_true * c_true) + eps
## Split test set (tiny)
n_test <- 10
Xc_te  <- matrix(rnorm(n_test * p), n_test, p)
Xt_te  <- matrix(rnorm(n_test * p), n_test, p)
## Indicators for test (all RCT by default is fine; give explicit here)
a_te <- rep(1L, n_test)
s_te <- rep(1L, n_test)
## Forest sizes (kept small for a quick run)
nt_control <- 50
nt_treat   <- 50
nt_deconf  <- 50
## Local HPs per your formula
local_hp_control <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_control))
local_hp_treat   <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_treat))
local_hp_deconf  <- (max(y) - min(y)) / (2 * 2 * sqrt(nt_deconf))
## Global HPs (only needed for non-fixed priors in your wrapper)
global_hp_control <- 1
global_hp_treat   <- 1
global_hp_deconf  <- 1
## Prior type:
prior_type_val <- "standard"
## Run the model (continuous outcome)
fit <- FusionShrinkageForest(
y                         = y,
status                    = NULL,
X_train_control           = Xc,
X_train_treat             = Xt,
treatment_indicator_train = a,
source_indicator_train    = s,
X_test_control            = Xc_te,
X_test_treat              = Xt_te,
# X_test_deconf omitted -> defaults to X_test_control
treatment_indicator_test  = a_te,
source_indicator_test     = s_te,
outcome_type              = "continuous",
timescale                 = "time",
number_of_trees_control   = nt_control,
number_of_trees_treat     = nt_treat,
number_of_trees_deconf    = nt_deconf,
prior_type_control        = prior_type_val,
prior_type_treat          = prior_type_val,
prior_type_deconf         = prior_type_val,
local_hp_control          = local_hp_control,
local_hp_treat            = local_hp_treat,
local_hp_deconf           = local_hp_deconf,
## leave sigma NULL (estimated), keep rho fixed to 1 for now
sigma                     = NULL,
rho                       = 1,
rho_known                 = TRUE,
## small MCMC for a smoke test; increase for real runs
N_post                    = N_post,
N_burn                    = N_burn,
store_posterior_sample    = TRUE,
verbose                   = TRUE
)
.restartR()
quit()
